---
layout: post
title: '[Algorithms] Part 02. Divide-and-conquer algorithms'
subtitle: 'Algorithms study'
categories: devlog
tags: algorithm
use_math: true
comments: true
---


저자 Dasgupta의 [Algorithms](https://www.flipkart.com/algorithms/p/itme28yppfu25bwe)을 해석하면서 정리한 글입니다.

# Part 2. Divide-and-conquer algorithms
**분할정복 알고리즘**은 문제를 더 이상 나눌 수 없을 때 까지 나누어서 각각 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘 입니다.

### `divide-and-conquer` 문제 해결 전략
1. 한 문제를 같은 크기를 갖는 몇 개의 subproblem들로 나눕니다. (devide)
2. 하위 문제를 recursive하게 풀어줍니다. 즉 각각에 대해서 subproblem을 구합니다. (conquer)
3. 각 subproblem들에 대해 합치거나 더 가공하여 최종 답을 냅니다. (combine)


## 2.1 Multiplication
> Given two n-bit positive integers x and y, calculate their product

문제 자체는 두 정수를 곱하라는 내용입니다. 평소 우리는 대부분 정수 곱셈을 $O(1)$만에 합니다. <br>
하지만 굉장히 큰 두 정수가 주어졌을 때, divied & conquer을 사용하여 곱셈을 할 수 있습니다.

우선 자연스럽게 n-bit 짜리 X와 Y를 2개로 쪼개보겠습니다.


$x =x_1 \cdot 2^{\lfloor{n/2}\rfloor}+x_0$

$y = y_1 \cdot 2^{\lfloor{n/2}\rfloor}+y_0$

그림으로 표현하면 아래와 같습니다.

![img](/assets/img/algorithm/algorithm01.jpeg)

그리고 x와 y를 곱하면 이런 식이 완성됩니다.

>$xy = x_1y_1\cdot 2^{2\lfloor{n/2}\rfloor} + (x_0y_1+x_1y_0)2^{\lfloor{n/2}\rfloor} +x_0y_0$

우리는 x를 $x_1$, $x_0$으로 y를 $y_1$, $y_0$으로 나누었습니다. 이를 각각 하나의 subproblem으로 볼 수 있습니다. 이 모두를 알고리즘으로 나타내보겠습니다.

### 1차 알고리즘
```
function Multiply(x,y)
    if n<=3:
        do the elementary math
    p_1 = Multiply(x_1, y_1)
    p_2 = Multiply(x_0, y_1)
    p_3 = Multiply(x_1, y_0)
    p_4 = Multiply(x_0, y_0)

    sol = p_1*2^{2*(n/2)}+(p_2+p_3)*2^{n/2}+p_4

    return sol
```
각각 쪼갠 subproblem들로 구해서 답을 내줍니다.

이제 위 알고리즘의 시간 복잡도를 계산해보겠습니다. 위 알고리즘의 시간 복잡도는 $O(n^2)$입니다.

Divide & Conquer 방식의 알고리즘은 시간복잡도 계산을 매우 편리하게 theorem이 존재합니다. 바로 [Master theorem](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms))이라고 불리는 이론입니다.

> Master theorem <br>
단순히 아래 식 parameter인 a, b, f(n)의 시간복잡도만 넣어주면 Divide & conquer의 시간복잡도가 계산이 되는 편리한 정리입니다.

![img](/assets/img/algorithm/algorithm03.png)

- $a$: divide & conquer에서 몇 개의 subproblem으로 나누는지, 한 레벨에서 재귀가 몇 번 불리는지 (subproblem의 개수)
- $b$: subproblem에 들어가는 input size가 기본 input 대비 줄어드는 비율의 역수
    - ex) subproblem / problem 개수
- $f(n)$: subproblem들을 combine하는 merging step에 드는 시간복잡도
    - ex) $a = 2$, $b = 2, f(n) = O(n)$일 때는 $log_22$ = 1인데, $\epsilon$은 0이 아닌 양수이므로 $n^1$을 만들 수 없습니다. 따라서 2번의 경우에서 $k = 0$인 경우라고 할 수 있습니다.

이를 지금 문제에 적용해보겠습니다. 위에서 하나의 `Multiply(x,y)`가 4개의 `Multiply()`를 호출합니다. 그리고 각 subproblem은 원래의 problem보다 크기가 1/2 줄어든 input을 받게 됩니다. <br>
그러므로 $a = 4, b = 2$ 입니다. 마지막으로 merging step에서는 2를 곱한다는 것은 bit를 앞쪽으로 한칸 씩 미는 것 입니다. 그러므로 liner time $O(n)$에 가능합니다.

이에 따라 1번 case를 적용시켜 $T(n) = \Theta(n^{log_24})$가 되어 $\Theta(n^2)$의 시간복잡도가 나옵니다.

### 2차 알고리즘
위 알고리즘보다 더 좋은 알고리즘을 만들 수 있습니다. 이유는 아래와 같습니다.

> $x_1y_0+x_0y_1 = (x_1 + x_0)(y_1 + y_0) - x_1y_1 - x_0y_0$

이렇기 때문에 굳이 `p_2 = Multiply(x_0, y_1), p_3 = Multiply(x_1, y_0)`를 추가적으로 부를 필요가 없습니다. 이미 갖고 있는 정보들을 이용해 조합을 하면 되기 때문입니다.

```
function Multiply(x,y)
    if n<=3:
        do the elementary math
    p_1 = Multiply(x_1+x_0, y_1+y_0)
    p_2 = Multiply(x_1, y_1)
    p_3 = Multiply(x_0, y_0)

    sol = p_2*2^{2*(n/2)}+(p_1-p_2-p_3)*2^{n/2}+p_3

    return sol
```

이렇게 `Multiply()` 호출 횟수가 줄었습니다. 그래서 다시 시간복잡도를 계산하기 위해 master theorem을 이용하면, $a = 3, b = 2$가 되어 총 시간복잡도는 $T(n)=\Theta (n^{log_2 4})$입니다.

### Conclusion
Devide & conquer에서는 배타적인 subproblem들로 문제를 나누어 각각에서 해답을 구하고 그것들을 이용해 최종 답을 이끌어내는데 이용합니다.

subproblem들이 나뉘어지는 경계선에 optimal solution이 걸쳐있는 경우가 존재할 때 merging(combining)  step에서 이를 고려하여야 합니다. <br>
divide & conquer에서는 이런 사실을 간과하기 쉬우므로 늘 조심해야 합니다.

## 2.2 Recurrence relations

**점화식(Recurrence)**: 어떤 함수를 자신과 똑같은 함수를 이용해 표현한 식 <br>
ex) 피보나치 수열 : $F(n) = F(n-1) + F(n-2)$

알고리즘의 시간 복잡도를 계산하다보면 아래와 같은 점화식이 생성된다. <br>
이는 `Master theorem`의 점화식으로 특정 형태의 재귀식에서 바로 결과를 도출하는 방법이다.

- 입력의 크기가 n인 문제를 풀기 위해 입력의 크기가 ${b \over n}$인 문제를 풀고, 나머지 $f(n)$의 오버헤드가 필요한 알고리즘의 점화식을 풀 수 있습니다.

> $T(n) = aT({n\over b}) + O(n^d)$
<br>

여기서 $a > 0, b > 1,$ and $d \geq 0$를 만족할 경우

> $T(n)$ = 
>> (1) $O(n^d)$     if $d > log_ba$ <br>
>> (2) $O(n^dlogn)$ if $d = log_ba$ <br>
>> (3) $O(n^{log_ba})$ if $d < log_ba$

위와 같이 시간복잡도가 계산됩니다.

> ex 1) 　　 $T(n) = 9T(n / 3) + n$ <br>
$a = 3, b = 3, f(n) = n$ <br>
$n<n^{log_39}=n^2$ 이므로 3번 경우에 해당합니다. 그러므로 시간 복잡도는 $T(n) = \Theta(n^2)$ 입니다.

> ex 2)  　　 $T(n) = T(2n / 3) + 1$ <br>
> $a = 1, b = 3/2, f(n) = 1$ <br>
> $n^{log_{3 \over 2}1}=n^0=1$ 이므로 1번 경우에 해당합니다. 그러므로 시간 복잡도는 $T(n) = \Theta(logn)$ 입니다.

여기서 a는 재귀 함수에서 불러오는 재귀함수의 개수, b는 한 재귀함수 내에서 제공되는 배열에서 사용하는 부분, d는 반복문의 복잡도로 나타낼 수 있습니다.

예를 들어 이진탐색을 구현한 코드를 살펴보겠습니다.

```c++
int BinarySearch(std::vector<int>& A, int low, int high, int target) {
	if (low >= A.size() || high >= A.size()) {
		return NOT_FOUND;
	}
	if (high < low) {
		return NOT_FOUND;
	}
	int mid = low + (high - low) / 2;
	if (target == A[mid]) {
		return mid;
	} else if (target < A[mid]) {
		return BinarySearch(A, low, mid - 1, target);
	} else {
		return BinarySearch(A, mid + 1, high, target);
	}
}
```
위 코드를 살펴보면, n만큼의 공간이 있는 배열 A에서 반절을 나눠 n/2만큼의 공간을 탐색하는 것이므로 b는 2가 됩니다. <br>
프로그램의 흐름이 `BinarySearch(A, low, mid - 1, target)`로 갈것이나 `BinarySearch(A, mid + 1, high, target)`로 가던지 한방향으로 갈 수 있으므로 a는 1이 됩니다. <br>
반복문이 없으므로 $n^0 = 1$ , 결국 $d=0$이 됩니다.

$d$가 $log_ba$ 보다 작으므로 $n^{log_ba} = 1^{log_2n} = O(logn)$이 됩니다.
<br><br>

**마스터 정리를 쓰기 위해선 세 가지 제약조건이 있습니다.**  <br>
1. $f(n)$은 다항식(polynomial function)이어야 합니다. 단 $f(n)$이 다항식이 아니더라도 극명하게 적용될 수 있음을 증명하면 사용할 수 있습니다. ($n^2 > nlogn$ 또는 $n^2 < n^2logn$)

2. $a \geq 1$와 $b >1$인 양의 실수이어야 합니다. 재귀를 호출할 때 그 호출 비용이 현재보다 작아야 한다는 것을 의미합니다. b가 1보다 작거나 같으면 오히려 문제가 그대로거나 커진다는 것을 의미합니다.

3. 정규 조건(Regularity condition)인 $af(n/b) \leq cf(n)$과 $c<1$을 만족하는 $c$가 존재해야 합니다. 이것 역시 subproblem이 현재 problem보다 작아져야 함을 의미합니다. 만약 $f(n)$이 지수 함수, 주기 함수의 경우 의심해봐야 합니다.

### 확장 마스터 정리(Extended or Advanced master theorem)
$f(n) =nlogn$인 경우 다항식이 아니기 때문에 마스터 정리를 이용할 수 없습니다. 하지만 확장 마스터 정리를 사용하면 시간 복잡도를 구할 수 있습니다. 이를 적용하기 위해 $f(n)$을 일반화 시켜줍니다. 
![img](/assets/img/algorithm/algorithm05.png)

여기서 $a$와 $b^k$를 비교하여 여러 케이스로 나뉩니다.

![img](/assets/img/algorithm/algorithm06.png)



## Reference
1. Algorithms - Dasgupta
2. https://hyunw.kim/blog/2018/09/18/Algorithm_Analysis02_Divide&Conquer.html
3. https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)
4. https://dad-rock.tistory.com/19
5. https://ferrante.tistory.com/47
6. https://coloredrabbit.tistory.com/94
7. https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=qkrgustnrk&logNo=220765180470

